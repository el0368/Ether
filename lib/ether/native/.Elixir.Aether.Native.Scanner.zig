// this code is autogenerated, do not check it into to your code repository

// ref lib/aether/native/scanner.ex:12
const beam = @import("beam");
const std = @import("std");

// --- SURGICAL FIX: Manual ABI Shim for Windows OTP 27+ ---
// The official erl_nif.h macros fail on Windows with Zig 0.15.x
// We explicitly define the struct layout to bypass the C-parser error.

const ERL_NIF_TERM = usize;
const ErlNifEnv = opaque {};
const ErlNifBinary = extern struct {
    size: usize,
    data: [*c]u8,
    ref_bin: ?*anyopaque,
    __reserved: [2]usize,
};

const TWinDynNifCallbacks = extern struct {
    enif_alloc: *const fn (usize) callconv(.c) ?*anyopaque,
    enif_free: *const fn (?*anyopaque) callconv(.c) void,
    enif_alloc_binary: *const fn (usize, [*c]ErlNifBinary) callconv(.c) c_int,
    enif_release_binary: *const fn ([*c]ErlNifBinary) callconv(.c) void,
    enif_make_binary: *const fn (*ErlNifEnv, [*c]ErlNifBinary) callconv(.c) ERL_NIF_TERM,
    enif_inspect_binary: *const fn (*ErlNifEnv, ERL_NIF_TERM, [*c]ErlNifBinary) callconv(.c) c_int,
    // We can map more as needed, but alloc/free/binary are the core needs.
    // The rest can be opaque pointers for now if not used directly by Zigler's internals
    // for this simple scanner.
};

// We shadow the broken cImport definition if it exists, or provide it if missing.
// In Zigler's generated code, it might try to use the one from @cImport.
// We rely on Zig's shadowing rules or just direct usage here.

// Real implementation
pub fn scan_directory(path: []const u8) !beam.term {
    // Industrial Safety: We handle the path as a slice
    var dir = std.fs.cwd().openDir(path, .{ .iterate = true }) catch |err| {
        return beam.make_error_pair(@errorName(err));
    };
    defer dir.close();

    var list = std.ArrayList(beam.term).init(beam.allocator);
    defer list.deinit();

    var iter = dir.iterate();
    while (try iter.next()) |entry| {
        const name_term = beam.make_slice(entry.name);
        const type_atom = switch (entry.kind) {
            .directory => beam.make_atom("directory"),
            .file => beam.make_atom("file"),
            else => beam.make_atom("other"),
        };
        
        const tuple_slice = &[_]beam.term{ type_atom, name_term };
        const entry_tuple = beam.make_tuple(tuple_slice);
        try list.append(entry_tuple);
    }

    return beam.make_list(list.items);
}
